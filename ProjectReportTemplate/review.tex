% \flushleft

\subsection{Development Process}

Overall our development process started out pretty chaotic and only improved over time by holding intensive discussions, receiving constructive feedback from the scrum master and partially on its own. Therefore, big portions of our development process are described in more detail later on in this report under the topic “6.3 Lessons Learned”.\\
\ \\
{\large\textbf{Comparing to 'the' textbook SCRUM process:}}\\
\begin{longtable}{|p{0.15\textwidth}|p{0.15\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}
\hline
    Criteria & Detail & Description & SCRUM of Group A\\
    \hline
    \hline
    Artefacts & Product Backlog & prioritized by product owner & prioritized by development team \\\cline{2-4}
      & Sprint Backlog & responsibility, status, assigned development team & sometimes no responssibility assigned, when task was added later in the sprint. Apart from that, we assigned tasks properly to team members or combinations of members and the status was clearly visible on our taskboard\\\cline{2-4}
      & Working increment of the software & early version with working features (features added over time and after client feedback) & most of the time working versions, but sometimes no finished represantation of feature (e.g. console output for Apriori) and not always completely finished feature, but instead almost done product \\
    \hline
    Roles & SCRUM team & self-organized small team, estimates size of artefacts & not completely self-organized, because daily SCRUM meeting times were mandatory and in certain time slots, but apart from that the team was completely independent and unlimited in the realm of the project constraints \\\hline 
     Roles & SCRUM master & coach, ensures practices are followed, shields team from e.g. management & Ms. Seddiki helped us in our sprint progress by giving conclusive feedback in our mid-sprint meetings \\\cline{2-4}
       & Prodcut Owner & excluded from development, communicates product vision & no dedicated owner in this project, since the whole team was involved in the development process \\
    \hline
    Time & Duration of a sprint and frequency of meetings & 14-30 days sprints, daily scrum meetings every day at fixed times & 14 days sprints, daily scrum meetings only on work days and at slightly different times (Tuesday and Thursday, most of the time between 4 and 8 p.m.) \\
    \hline
    Meetings & Daily SCRUM meetings & short daily meetings with small development team for updates about the current status, occurring problems and repeating the sprint goal & meetings not entirely daily, but instead on every working day (usually Tuesday, Wednesday and Thursday); early on in the project, our daily scrum meetings were too long and unnecessarily detailed, later on shorter compact meetings (5-15 min) \\
    \hline
    \hline
  \caption{Comparing to 'the' textbook SCRUM process:}
\end{longtable}

Apart from this direct comparison, there were some stark contrasts between the textbook SCRUM process and our group’s development process (again: some of this is mentioned in greater detail under “6.3 Lessons Learned”), which only lessened over the course of the project. For example our sprints started out not closed in themselves: we struggled to finish the planned sprint backlog in the first sprint due to some initial confusion, underestimating the size of the major user story for this sprint and not yet present highly efficient team communication, which only developed after the first sprint. This resulted in us falling short of the aspired milestone in sprint 1 and thus carrying the unfinished workload over into the second sprint, which is – of course – not how textbook SCRUM is supposed to work. At the beginning of sprint 3, we fortunately were on-par again with our previous estimation and completed the leftover sprint tasks, just before the change request fiasco described in “6.3 Lessons Learned – Change Request” happened. Although this underestimation and carrying over had a massive negative impact on our whole project progress, we think, this is a useful lesson learned for future projects and the SCRUM way of having closed sprints and working increments of software is far more desirable. Additionally, we continuously used extensive manual documentation for us and the SWT lehrstuhl, instead of the in SCRUM a lot more common approach of having little and only automated documentation.\\
\ \\
{\large\textbf{Comparing to the general software development lifecycle:}}\\ 
\ \\
Before doing anything else, our group extracted all functional and non-functional requirements, constraints and User Stories from the project brief and grouped them properly. In contrast to an agile development process, we didn’t just put the user stories into our product backlog, but we also gave them a certain order and maybe planned a little bit too far ahead at that time. After the requirements, we continued with answering the few left-open questions regarding a fitting architecture, because the project brief already limited the possibilities and required a certain type of architecture. After this step, our design phase was also quite similar to the standard design phase, where we drafted our internal data structure and sketched some possible classes, interfaces and the relations between them. In the implementation phase, we started coding our previously drafted design, but unfortunately the testing phase was neglected a little bit. Early on we tested a few classes with little detail and low coverage and only in the next sprints we started to put more effort and time into more extensive testing, after we found some rather obvious bugs, which could’ve been prevented or at least spotted earlier, if proper testing had been done in the first sprints. The deployment phase including the customer validation was executed normally with the only difference that our documentation was compiled all throughout the project and sprints and not only afterwards. The support phase did not play a big role in our development process, due to the sprint schedule, but feature requests were of course discussed with the client in the sprint review meetings. In later sprints, the requirements gathered via client feedback were assessed and added, the architecture rarely reworked instead only slightly adapted and the design phase for new components was done just like previously mentioned. Overall, our development process didn’t deviate from the software development lifecycle that much, although we caught ourselves thinking ahead a little bit too much at some points: a few times, we held discussions about technically specific detailed tasks and performance issues before talking about the more high-level and obvious decisions and subjects of a given task or user story. Most often, someone noticed and noted this before the discussion sprung out of control, but when discussing the Apriori algorithm, everyone was thinking too far ahead. This had the negative repercussions that we started intensively coding for a few valuable working hours, before noticing our lack of understanding of the subject at hand and having to discard some previously written code, because the approach was just inherently wrong. \\
\ \\
{\large\textbf{Comparing to other software development processes:}}\\ 
\ \\
Since we tried to stick to the SCRUM model as good as possible, our project has only very little in common with most of the other popular software development processes, apart from the usual and known overlaps. Our whole scrum sprints always presented (partially) working increments like in the incremental development, where we revised each working increment and the underlying code again after receiving client feedback in the sprint review meetings. Similar to the component-based development, we worked with interfaces at different points like with the Apriori analyser and only later in the sprint with the Apriori analyser as the sprint goal, we implemented the actual functionality. Also elements like the Apriori analyser and the comparison view are both just components, we added to our code, without them affecting or modifying any of the previously existing code. The only similarity to extreme programming is that we programmed in pairs most of the time and especially in the earlier development stages tried to refactor the code wherever possible.\\


\subsection{Team Work}

Fortunately, our group started to cooperate and communicate pretty well from the beginning of the project. Some of us knew each other beforehand to some extent, which helped in breaking down any upfront barriers of communication. Even before the official start of the project we exchanged numbers and managed ourselves in a social communication app to easily inform other group members in case of illness or delay for the meetings. All project specific information was exclusively exchanged in our SWT lab meetings. Our group’s composition consists of different WIAI degree programs, which was a major aspect of and benefit to our success, since everyone had a slightly different background and expertise. Some of us have an advanced grasp on complex coding mechanisms, others have profound know-how in GUI development, someone focuses on the group communication and management and other group members again have in-depth theoretical knowledge. This was also the main reason why we developed and drafted big portions of our project in pairs – the weakness of one member is balanced by another one’s strength in the same topic. Another factor for picking pair programming as our main development technique is its benefit in preventing illnesses and absences from affecting the project progress. Extensive documentation also helps with this problem of course, but using pair programming granted us a double safety-net. Overall we think the drawbacks from having two persons work on the same task together instead of one person per task are negligible compared to the many advantages of this technique, also including more efficient code in general. There were a few moments in our project development where someone was stuck at some point and often times it was due to a fault in the person’s approach, which could only be resolved by introducing another group member’s perspective and opinion to the task. Also by programming alone, you oftentimes don’t even realize that your current task progress is leading into a dead end – this is no problem when another group member works together with you on the same task and frequently gives input and shares their approach with you. \\
\ \\
The distribution of work was always split equally between our group members, because there was never a time, where all work was completed and nothing left to improve. If the progress towards reaching the sprint goal relied on just a pair of team members while all other development could not continue at the same time, the rest of the team occupied their time with refactoring code, writing additional tests, drafting material for upcoming tasks, sketching mockups and preparing for the next mid-sprint meeting and sprint review meeting. All in all, the team communication and equal distribution of work were the biggest strengths of our team and helped immensely with this project. Not only the previously mentioned obvious benefits had a high impact on the success of the project, but also the hidden advantages like a good climate between the group members and the thus resulting increased motivation aided in the effective progress throughout the project.\\
\ \\
The communication with the client worked rather well: over the course of the project, we always had the impression, the client and our group shared the same vision on the project and its goals. Whenever we weren’t sure about an aspect of our aspired project, we would sketch a mockup and just ask the client on specific feedback, which was precise, honest and constructive at all times. Also on our part, we consistently strived – and achieved - to adapt our product as good as possible to the client’s feedback, ideas and suggestions.\\
\ \\
It’s also worth noting that the only slight problem we had with internal team work, was one of our group members leaving the SWT project in the early stages of development in the first sprints. Fortunately, this was not entirely unexpected, so we planned our sprints with this risk in mind. In hindsight, this departure didn’t really affect the group’s progress at all, apart from us having to split all work between five instead of six members. Another group member leaving would probably have a devastating effect on the project’s success, therefore, after the first member leaving, we held a serious discussion and talked about what this project meant to us and how every group member would assess their own risk of leaving the project in stressful times. Fortunately, we concluded from this discussion that our project was not in any danger of another member leaving and the risk of this happening was low enough to continue as a five-man group.\\


\subsection{Lessons Learned}

We as a group and as individuals learned a lot during this project. Some of these lessons come from pretty obvious mistakes, but some lessons were learned only by discussing the project as a group afterwards. The following is an unordered list of findings, we compiled while conducting the just mentioned discussion:\\
\ \\
\textbf{Additional material} (e.g. diagrams): It’s no use, sketching and improving supporting material just for the sake of it and for having something to show the scrum master – instead, actually using the diagrams and improving them and our own project in parallel is a great help for developing the program. We started sketching some diagrams early in the first sprints, but the diagrams never depicted our current version of the system and therefore were of little value to us. Only after sketching activity diagrams for the system’s basic functions and getting some helpful feedback from Ms. Seddiki, we found a crucial flaw in our system that changed our view on the usefulness of diagrams and other supportive material. From that point on it was not “finish coding, draw diagrams afterwards” anymore, but rather “sketch some fitting (low-level) diagrams to display how the upcoming task should work in theory and then improve both the code and diagram according to results”.  \\
\ \\
\textbf{Presentation}: After the harsh feedback from our client along the lines of “your product looks great, but I wouldn’t buy it, because you didn’t try to sell it to me”, we realized the importance of those sprint review meetings not only to get appropriate feedback, learn to sell our product, but also for our group self-confidence. We knew, we had a decent product, but we never went into the presentations with the proper confidence and conviction. So of course the client didn’t get the feeling, our product was valuable and worthwhile. The lesson learned is that we should’ve been better prepared and more confident for the presentations to get even better feedback and additional motivation for the continuing development. Having the 8 a.m. slot cannot be an excuse for that. \\
\ \\
\textbf{Taskboard}: In our first sprint review meeting our client gave us the tip to write the sprint goal in the last column of our taskboard, so we always know, what our aim is and where we are heading with this sprint. This was a great advice, because we started working more towards the sprint goal instead of just the necessary tasks to get there. The taskboard in general was and is an overall very useful tool to keep an overview over the current development progress, increase the group’s focus and free everyone’s mind by not having to remember the overwhelming number of pending tasks. Unfortunately, we started with oversized tasks and user stories, which we only began splitting in smaller tasks and stories while the sprint was already in progress. This had the negative consequence that we forgot to update and extend the responsibilities assigned in our sprint planning meeting to the newly created tasks and user stories. Therefore, some tasks were neglected for too long and only tackled, once the sprint was almost over. This problem became less of an issue when we started to have more meaningful sprint planning meetings and got better at defining minimal tasks and user stories. If we were to re-start the project, we would also have clearer and more concise tasks, which are labeled properly (corresponding sprint, related user story number, responsible team member). We only learned the previous lesson halfway through after Sprint 3.\\
\ \\
\textbf{Change Request}: Although we managed to incorporate the change request in our project rather smoothly and quickly, we did not talk about and discuss it properly beforehand. We just jumped on the emerging tasks and postponed all other current development (namely Apriori development), which delayed our whole work and made us barely miss the goal of the sprint. We talked about this extensively in the following sprint review meeting, which confirmed our assumption that this was not the correct way to tackle change requests in a closed SCRUM sprint. If we were to do a similar project in the future with a similar change request, we would now discuss it thoroughly before starting any work on the request and then decide, whether we are going to redo the sprint planning meeting and abort the current sprint goal or continue development as planned and work on the change request in an upcoming sprint. Our team’s motivation also suffered because of this, since we – again – didn’t meet the sprint goal at the sprint review meeting deadline, although we were right on track to have a properly working increment with all the promised features for the first time in this week’s client presentation. \\
\ \\
\textbf{Sprint Review Meeting}: Apart from some issues mentioned earlier under the point “presentation”, the meetings were a great tool for us to get some feedback. Especially confirming the conformity of our vision of the project (e.g. by showing a low-level paper-mockup) with the views of the client is crucial in developing a sellable product. We also managed to include the client’s feedback and feature requests quite well and according to his imagination in our product. When submitting our first few additional usage scenario proposals, we only considered medatixx as our client and underestimated the significance of the SWT lehrstuhl as our second client. This resulted in our first proposals only being smaller nice-to-have-features and not the required sprint-filling substantial additional scenarios, which are required for this project. \\
\ \\
\textbf{Sprint Planning Meeting}: After the previously mentioned advice to write down the sprint goal on the taskboard, we started to put more focus in the labeling of our sprint goal in the sprint planning meeting. Over time, we also became better at assessing our group’s strengths and weaknesses and whereas our first and second sprints were cramped with way too many and too large user stories and tasks, the following sprint estimates and goals were more tuned to our actual development speed and intensity. After the first three sprints, we began to note down and repeat all not yet processed tasks in the sprint planning meeting so that we didn’t fall in the trap of starting a new feature while the old one is not done yet. This helped us a lot in organizing and structuring our group work and we would definitively benefit from this lesson learned in a theoretical re-start of this project.\\
\ \\
\textbf{Daily SCRUM Meetings}: At the beginning of our project development, we did not have any experience with daily scrum meetings apart from the theoretical information provided in the course introduction and in the FSE module. Therefore, we were pretty confused on how these daily scrum meetings are supposed to help us structure the development, thus the first handful of meetings was highly inefficient and only meant to meet the project’s documentation demands. As time went by and as we received more and more feedback from our scrum master, our meeting progressively started to improve: We were more honest with our impediments and asked other team members for help, when something didn’t go as planned. We stopped talking about everything we did in great detail, but rather learned to give a quick and compact overview over our past and future work. The results of this change were incredibly beneficial for our development flow. We reduced the unnecessary overhead to just 5 – 15 minutes of compact information about the current team’s progress – without decreasing the level of content, thus our whole group became better organized and our development started to feel more fluid and more like SCRUM is supposed to feel. \\
\ \\
\textbf{Documentation}: Just like with all the meetings, our documentation also started out as pretty dire and chaotic: differing wording, lots of spelling mistakes, no consistent format and sometimes not even up-to-date content. By improving our meetings overall and receiving feedback from our scrum master, we also fixed our documentation flaws over time. This was a slow process, but we definitely learned what makes good – and bad - documentation and how documentation can actually help the group’s development progress instead of being just an overhead-burden. \\
\ \\
\textbf{Risk analysis}: The risk analysis in the blastoff phase required us to think through all possible problem scenarios and be honest with ourselves regarding the risk that someone in the group spontaneously leaves during the development phase. This proved to be an interesting task and should definitely stay the same in a reiteration of the project.\\
